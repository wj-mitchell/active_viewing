---
title: "Analysis"
author: "William J. Mitchell"
date: "`r Sys.Date()`"
output: html_document
---

```{r Setup}
## If the pacman package manager is not currently installed on this system, install it.
if (require("pacman") == FALSE){
  install.packages("pacman")
}

## Loading in my packages with my pacman manager
pacman::p_load(corrplot,
               here,
               lme4,
               lmerTest,
               performance,
               reshape2,
               tibble,
               tidyverse)

## Setting Working Directory
(dir_Work <- here::here())
```

## ----- READING IN QUALTRICS DATA -----

```{r Pulling in the Qualtrics Data}
## From this we want to know who participants had thought had done it at the end of each section
df_qual <- read.csv(paste0(dir_Work, "/3_Data/Qualtrics/df_qualtrics.csv"))

## Noting who rated which half
df_qual$Rated <- NA
df_qual$Rated[which(df_qual$PID %in% unique(subset(read.csv(paste0(dir_Work, "/3_Data/Ratings/df_behav.csv")), Condition == "A")$PID))] <- "First" 
df_qual$Rated[which(df_qual$PID %in% unique(subset(read.csv(paste0(dir_Work, "/3_Data/Ratings/df_behav.csv")), Condition == "B")$PID))] <- "Last" 
```

## ----- READING IN RECALL DATA -----

```{r Reading in the Raw Recall DAta}
df_recall <- read.csv(paste0(dir_Work,"/3_Data/Recall/df_recall.csv")) %>%
  
             # Remove all rows in which every value is NA
             na.omit() %>%
      
             # Patching up the PID variable names (Can't have variable names that start with numbers)  
             mutate(PID = paste0("SR-", sprintf("%04d", as.integer(PID))))
```

# ----- SERIAL POSITION CURVE ANALYSIS -----

## Organizing the data

```{r Creating a New Empty Dataframe to Rehouse the Data Into}
# Save every unique PID as a variable
PIDs <- unique(df_recall$PID)

# Specifying the names of rows and columns in the new dataframe
cols <- c("PID", "Scene", "Recalled")
rows <- 1:((length(PIDs)) * 35)

# Creating  the new dataframe
df_recall_wide <- as.data.frame(matrix(NA, 
                               nrow = length(rows), 
                               ncol =  length(cols),
                               dimnames = list(rows,
                                               cols))) %>%
  
                   # Repeating the numbers 1 through 35 a number of times equivalent to the number of unique PIDs there are
                   mutate(Scene = PIDs %>% length() %>% rep(1:35, .),
                          
                          # Repeating each of the unique PIDs a number of times equivalent to the number of scenes there are and sorting them alphanumerically
                          PID = PIDs %>% rep(., 35) %>% sort()) 

# Cleaning space
rm(cols,rows)
```

```{r Filling in Recall Data}
# Make all data equal to 0
df_recall_wide$Recalled <- 0

# Iterate through every PID
for (PID in PIDs){
  
  # Iterate through every scene
  for (SCENE in unique(df_recall_wide$Scene)){
    
    # If any PID / Scene combo is present in the original dataframe
    if (any(df_recall$PID == PID & df_recall$Scenes == SCENE)){
      
      # Then find that PID / Scene Combo in the new dataframe and change the 0 to a 1
      df_recall_wide$Recalled[df_recall_wide$PID == PID & df_recall_wide$Scene == SCENE] <- 1
    }
  }
}
rm(PID, df_recall)
```

```{r Pivoting the Dataframe to Wider Format}
# Pivoting to a wider format
df_recall_wide <- pivot_wider(df_recall_wide,
                              names_from = PID,
                              values_from = Recalled) %>%
                  .[-c(3,7,14,26,29,32,34),] # Removing B-Roll Transitions
```

```{r Calculating the Average}
# Calculating the average relative order of each scene
df_recall_wide$GroupAvg <- rowMeans(df_recall_wide[,2:ncol(df_recall_wide)], na.rm = T)
```

```{r Visualizing the Serial Position Curve}
# Plotting
plot(df_recall_wide$Scene, df_recall_wide$GroupAvg, type = "l")
```

```{r Converting Back to Long Format}
# So now that we have space for all events, forgotten or recalled, let's convert *back* to a long format for the sake of analysis
df_recall_long <- df_recall_wide %>%
                  pivot_longer(cols = starts_with("SR-"),
                               names_to = "PID",
                               values_to = "Recalled") %>%
                  select(c(PID,Scene,Recalled)) %>%
                  merge(.,
                        subset(df_qual, !is.na(df_qual$Rated), select = c("PID","Rated")), 
                        by = "PID") %>%
                  mutate(Half = ifelse(Scene < 19.5, "First", "Last"),
                         Congruent = ifelse(Rated == Half, "Rated", "Not Rated"),
                         Recalled_Cat = ifelse(Recalled == 1, "Recalled", "Not Recalled"))
```

## Analyzing the Data

```{r Chi Square Test for Rating}
# Creating a chi-square test to determine whether there are differences in what proportion of scenes subjects recall by whether the scenes occurred while they were rating or not rating
chisq.test(x = df_recall_long$Congruent,
           y = df_recall_long$Recalled_Cat)
```

```{r Visualizing Recall Chi-Square}
# Visualizing the chi square results
  plot <- ggplot(data = df_recall_long, aes(x = Congruent, color = Recalled_Cat, fill = Recalled_Cat)) +
        geom_bar() +
        # scale_x_discrete("Condition") +
        scale_y_continuous(breaks = c(0,100,200,300,400)) +
        labs(
             x = NULL,
             y ="Frequency") +
        scale_color_brewer() +
        scale_fill_brewer(palette = "Accent") +
        coord_cartesian(ylim=c(0.0, 425.0)) +
        theme_classic() +
        theme(plot.title = element_text(face="bold", size=8, hjust = 0.5)) +
        theme(plot.subtitle = element_text(size = 10, hjust = 0.5, face = "italic")) +
        theme(plot.caption = element_text(size = 8, hjust = 0.0, face = "italic")) +
        theme(axis.title = element_text(size = 10)) +
        theme(axis.text.x = element_text(size = 14, color = "Black")) +
        theme(axis.text.y = element_text(size = 12, color = "Black")) +
        theme(legend.key.size = unit(0.5, 'cm')) +
        theme(legend.title = element_text(size=8)) +
        theme(legend.text = element_text(size=6))
  plot
```

```{r Constructing a within subject summary dataframe}
# Constructing a summary dataframe to capture the proportion of rated and not rated events captured in each subject's free recall 
df_summary <- df_recall_long %>% group_by(PID, Congruent) %>%
              summarize(Proportion_Recalled = mean(Recalled == 1, 
                                                   na.rm = TRUE))

# Conducting a within-subject t-test between rated and not rated scenes
t.test(x = df_summary$Proportion_Recalled[df_summary$Congruent == "Rated"],
       y = df_summary$Proportion_Recalled[df_summary$Congruent == "Not Rated"],
       paired = T)
```


```{r}
rating <- paste0(dir_Work, "/3_Data/conditions.csv") %>%
  read.csv() %>% 
  .[,1:2]

df_rsa <- df_recall_wide %>%
  
  # Step 1: Select only the Assessment columns
  select(starts_with("SR-")) %>%

  # Step 2: Calculate pairwise correlations across all Assessment columns
  cor(use = "complete.obs") %>%
  
  # Step 3: Remove the upper triangle by setting it to NA
  { .[upper.tri(., diag = TRUE)] <- NA; . } %>%

  # Step 4: Melt the matrix for ggplot
  melt(na.rm = TRUE) %>%
  
  # Step 5: Add condition columns by joining with rating data
  left_join(rating, by = c("Var1" = "Subject")) %>%
  rename(Condition_Var1 = Condition) %>%
  left_join(rating, by = c("Var2" = "Subject")) %>%
  rename(Condition_Var2 = Condition) %>%
  
  # Step 6: Add a column indicating if the conditions match or not
  mutate(Condition_Match = ifelse(Condition_Var1 == Condition_Var2, "Match", "Do Not Match"))

# Calculating if there's a difference by condition in a t-test
print(t.test(x = df_rsa$value[df_rsa$Condition_Match == "Match"],
             y = df_rsa$value[df_rsa$Condition_Match == "Do Not Match"]))
  
  # for reproducibility
  set.seed(123) 
  
  # Assuming `similarity_matrix` is your dataframe with same/different condition categorization
  observed_diff <- df_rsa %>%
    group_by(Condition_Match) %>%
    summarize(mean_correlation = mean(value)) %>%
    spread(Condition_Match, mean_correlation) %>%
    summarize(diff = `Match` - `Do Not Match`) %>%
    pull(diff)
  
  # Initialize parameters
  n_permutations <- 5000
  permuted_diffs <- numeric(n_permutations)
  
  # Permutation loop
  for (i in 1:n_permutations) {
    
    # Randomly shuffle condition labels
    shuffled_conditions <- sample(df_rsa$Condition_Match)
    
    # Calculate mean difference for shuffled data
    permuted_diff <- df_rsa %>%
      mutate(Shuffled_Condition = shuffled_conditions) %>%
      group_by(Shuffled_Condition) %>%
      summarize(mean_correlation = mean(value)) %>%
      spread(Shuffled_Condition, mean_correlation) %>%
      summarize(diff = `Match` - `Do Not Match`) %>%
      pull(diff)
    
    # Store the permuted difference
    permuted_diffs[i] <- permuted_diff
  }
  
  # Calculate p-value
  p_value <- mean(abs(permuted_diffs) >= abs(observed_diff))
  
  # Display results
  cat("Observed Difference:", observed_diff, "\n")
  cat("p-value:", p_value, "\n")



```

```{r Calculating Averages by Rating Status}
df_recall_wide$FH_Avg <- NA
df_recall_wide$SH_Avg <- NA

df_recall_wide$FH_Avg <- rowMeans(df_recall_wide[,which(names(df_recall_wide) %in% raters_FH)], 
                                     na.rm = T)
df_recall_wide$SH_Avg <- rowMeans(df_recall_wide[, which(names(df_recall_wide) %in% raters_SH)], 
                                                          na.rm = T)

## Cleaning Our Space
rm(Jon_FH, Jon_SH, NoJon_FH, NoJon_SH, raters_FH, raters_SH)
```

```{r Standard Serial Position Curve}
# Create the first plot
plot(df_recall_wide$Scene, df_recall_wide$FH_Avg, type = "l", 
     col = "blue", xlab = "Scene Number", ylab = "Proportion Recalled", 
     main = "Serial Position Curve - First v. Second Half")

# Add the second line
lines(df_recall_wide$Scene, df_recall_wide$SH_Avg, type = "l", col = "red")
```


```{r Standard Serial Position Curve}
# Create the first plot
plot(df_recall_wide$Scene, df_recall_wide$Jon_Avg, type = "l", 
     col = "green", xlab = "Scene Number", ylab = "Proportion Recalled", 
     main = "Serial Position Curve - Jonathan v. Not Jonathan Theory")

# Add the second line
lines(df_recall_wide$Scene, df_recall_wide$NoJon_Avg, type = "l", col = "purple")
```

## Synchrony Analysis

```{r Calculating Recall Synchrony}
## Constructing a correlation matrix
df_recall_cor <- cor(df_recall_wide[,which(str_detect(colnames(df_recall_wide), "SR-"))],
                     method = "spearman")

# Convert the correlation matrix to a long format dataframe
df_recall_cor <- melt(df_recall_cor)
  
# Name the columns for clarity
names(df_recall_cor) <- c("PID_2", "PID_1", "Recall_Correlation")
  
# Remove redundant pairs (upper triangle and diagonal)
Delete_Rows <- NULL
for (ROW in 1:nrow(df_recall_cor)){
  if (which(df_recall_cor$PID_1[ROW] == sort(PIDs)) >= which(df_recall_cor$PID_2[ROW] == sort(PIDs)))
    Delete_Rows <- c(Delete_Rows, ROW)
}
df_recall_cor <- df_recall_cor[-Delete_Rows,]
```

```{r Calculating Behavioral Synchrony}
df_FH <- SceneByRating(Data = paste0(dir_Work, "/Data/df_behav_.csv"),
                    Cond = "A",
                    SceneBreaks = c(0, 189, 241, 243, 419,
                                   431, 521, 527, 581, 625,
                                   757, 797, 827, 877, 885,
                                   983, 1133, 1273, 1291, 1337),
                   RunCor = T) 

df_SH <- SceneByRating(Data = paste0(dir_Work, "/Data/df_behav_.csv"),
                    Cond = "B",
                    SceneBreaks = c(0, 14, 28, 75, 158,
                                   186, 279, 283, 335,
                                   398, 405, 681, 877,
                                   604, 1062, 1067, 1337),
                    RunCor = T) 

# Binding the dataframes together for First and Second Half Raters
df_SceneByRating <- rbind(df_FH,
                       df_SH)

# Name the columns for clarity
names(df_SceneByRating) <- c("PID_2", "PID_1", "SceneByRatingrelation")

## Cleaning Space 
rm(df_FH, df_SH)
```

```{r Merging Dataframes}
df_cor <- merge(df_recall_cor,
                df_SceneByRating,
                by = c("PID_1", "PID_2"))
```

```{r}
df_cor$Theory <- NA

# Iterating through each PID twice
for (PID1 in unique(df_qual$PID)){
  for (PID2 in unique(df_qual$PID)){
    if (PID1 != PID2){ 
      if (df_qual$Rated[df_qual$PID == PID1] == "First" & !is.na(df_qual$Rated[df_qual$PID == PID1])){
        if (df_qual$Mid_Theory[df_qual$PID == PID1] == df_qual$Mid_Theory[df_qual$PID == PID2]){
          df_cor$Theory[df_cor$PID_1 == PID1 & df_cor$PID_2 == PID2] <- "Same"
        }
        if (df_qual$Mid_Theory[df_qual$PID == PID1] != df_qual$Mid_Theory[df_qual$PID == PID2]){
          df_cor$Theory[df_cor$PID_1 == PID1 & df_cor$PID_2 == PID2] <- "Different"
        }
      }
      if (df_qual$Rated[df_qual$PID == PID1] == "Last"& !is.na(df_qual$Rated[df_qual$PID == PID1] )){
        if (df_qual$End_Theory[df_qual$PID == PID1] == df_qual$End_Theory[df_qual$PID == PID2]){
          df_cor$Theory[df_cor$PID_1 == PID1 & df_cor$PID_2 == PID2] <- "Same"
        }
        if (df_qual$End_Theory[df_qual$PID == PID1] != df_qual$End_Theory[df_qual$PID == PID2]){
          df_cor$Theory[df_cor$PID_1 == PID1 & df_cor$PID_2 == PID2] <- "Different"
        }
      }
    }
  }
}
```

```{r Running a null HLM to see if Rating Synchrony Predicts Recall Synchrony}
m0 <- lmer(Recall_Correlation ~ 1 + (1|PID_1) + (1|PID_2), data = df_cor, REML = F)
icc(m0)
```

```{r Testing Our Hypothesized Interaction Model}
m1 <- lmer(Recall_Correlation ~ SceneByRatingrelation * Theory + (1|PID_1) + (1|PID_2), data = df_cor, REML = F)
summary(m1)
```

```{r Specifying a Comparison Model for Comparison}
m2 <- lmer(Recall_Correlation ~ SceneByRatingrelation + Theory + (1|PID_1) + (1|PID_2), data = df_cor, REML = F)
anova(m2,m1)
```

```{r}
sjPlot::plot_model(m1, type = "int")
```
